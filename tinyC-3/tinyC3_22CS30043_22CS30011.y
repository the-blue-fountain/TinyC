%{  

//Translator file containing data structures and function prototype
#include "tinyC3_22CS30043_22CS30011_translator.h"

//Declaration of C++ header files
#include <iostream>              
#include <cstdlib>
#include <string>
#include <stdio.h>
#include <sstream>

using namespace std;

extern string var_type;			// last encountered variable type
extern int yylex(); 			// Generated by Flex
void yyerror(string s);			// error recovery

%}

//declaring data types to be included in yylval
%union {            		
	
	Expression* expr;		   //expression
	Statement* stat;		   //statement	
	Array* Arr;  		   	   //array type

	char unaryOp;	  		   //unary operator		
	char* char_value;		   //char value

	int instr_number;		   //instruction number used for backpatching
	int int_value;			   //integer value	
	int num_params;			   //number of parameters

	symboltype* sym_type;	   //symbol type  
	sym* sym_ptr;			   //symbol pointer
}  

// -------------------------- TOKEN DECLARATION --------------------------------

%token <sym_ptr> IDENTIFIER

%token <int_value> INTEGER_CONSTANT
%token <char_value> FLOAT_CONSTANT
%token <char_value> CHARACTER_CONSTANT
%token <char_value> STRING_LITERAL

%token ROUND_BRACKET_OPEN ROUND_BRACKET_CLOSE
%token SQUARE_BRACKET_OPEN SQUARE_BRACKET_CLOSE
%token CURLY_BRACKET_OPEN CURLY_BRACKET_CLOSE

%token UNARY_INCREMENT UNARY_DECREMENT NOT
%token MUL DIV MOD PLUS MINUS COMPLEMENT XOR
%token DOT DOTS COMMA QUES_MARK COLON SEMICOLON
%token IMPLIES HASH

%token BITWISE_LEFT BITWISE_RIGHT BITWISE_AND BITWISE_OR
%token LOGICAL_AND LOGICAL_OR
%token LESS_THAN GREATER_THAN LESS_EQUAL GREATER_EQUAL EQUAL NOT_EQUAL

%token ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN PLUS_ASSIGN MINUS_ASSIGN 
%token BITWISE_LEFT_ASSIGN BITWISE_RIGHT_ASSIGN BITWISE_AND_ASSIGN XOR_ASSIGN BITWISE_OR_ASSIGN

%token EXTERN STATIC VOID CHAR SHORT INT LONG FLOAT DOUBLE CONST RESTRICT VOLATILE INLINE SIZEOF TYPEDEF UNION STRUCT

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN 

//Setting precedence for handling Dangling-if-else shift-reduce conflict 
%right "LOWER_THAN_ELSE" ELSE

//Auxillary non-terminals M and N used for backpatching
%type <instr_number> M 	//store the next instruction to allow control flow
%type <stat> N 			//store the nex instruction list to allow control flow

//Expressions
%type <expr>
	expression
	expression_opt
	primary_expression 
	multiplicative_expression
	additive_expression
	shift_expression
	relational_expression
	equality_expression
	AND_expression
	exclusive_OR_expression
	inclusive_OR_expression
	logical_AND_expression
	logical_OR_expression
	conditional_expression
	assignment_expression
	expression_statement

//unary operator
%type <unaryOp> unary_operator

//number of parameters
%type <num_params> argument_expression_list argument_expression_list_opt

//n dimensional arrays
%type <Arr> 
	postfix_expression
	unary_expression
	cast_expression

//Statements
%type <stat>  
	statement
	compound_statement
	selection_statement
	iteration_statement
	labeled_statement 
	jump_statement
	block_item
	block_item_list
	block_item_list_opt

//Symbol type
%type <sym_type> pointer

//Symbol
%type <sym_ptr> initializer
%type <sym_ptr> direct_declarator init_declarator declarator


// ------------------------ STATING THE STARTING NON-TERMINAL SYMBOL ------------
%start translation_unit

%%

// -------------------------------- 1. EXPRESSIONS ------------------------------


primary_expression 
		: IDENTIFIER 								//expression : identifier
		{     
			$$ = new Expression();            		//Creating new expression object 		
			$$->type = "not-boolean";				//stating type of identifier
				 
			//storing the location of the Symbol table where the identifier is present
			$$->location = $1;						
			
		}
		| INTEGER_CONSTANT				   			//expression : integer constant
		{    
			$$ = new Expression();	       			//Creating new expression object
			
			string str = convertInt2String($1);     //converting integer constant to string  
			
			//creating a temporary variable with initial value as string form of integer constant ; storing the location of the symbol table where the temporary variable is present
			$$->location = gentemp(new symboltype("int"),str);      
			
			emit("=",$$->location->name,str);      // temp : string(integer constant)
			
		}
		| FLOAT_CONSTANT				   			//expression : floating point constant
		{  
			$$ = new Expression();	       			//Creating new expression object
			
			//creating a temporary variable with initial value as string form of float constant ; storing the location of the symbol table where the temporary variable is present
			$$->location = gentemp(new symboltype("float"),$1);
			
			emit("=",$$->location->name,string($1));  // temp : string(float constant)
			
		}
		| CHARACTER_CONSTANT               			//expression : character constant
		{    
			$$ = new Expression();					//Creating new expression object
			
			//creating a temporary variable with initial value as character ; storing the location of the symbol table where the temporary variable is present
			$$->location = gentemp(new symboltype("char"),$1);
			
			emit("=",$$->location->name,string($1));  // temp : character constant
			
		}
		| STRING_LITERAL  				  			//expression : string literal
		{   
			$$ = new Expression();					//Creating new expression object
			
			//creating a temporary variable with initial value as base address of the string literal; storing the location of the symbol table where the temporary variable is present
			$$->location = gentemp(new symboltype("ptr"),$1);
			
			$$->location->type->arrtype=new symboltype("char");   
			
		}
		| ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE    //expression : expression
		{   
			$$ = $2;								//equity of expression
		}
		;

postfix_expression 
		: primary_expression 
		{
			$$ = new Array();                        //creating a new Array object
			
			$$->location = $$->Array;				 //storing location of Array
			
			$$->Array = $1->location;				 //array pointing to the location of primary expression
			
			$$->type = $1->location->type;			 //type(postfix expr) : type(primary expr)	
			
		}
		| postfix_expression SQUARE_BRACKET_OPEN expression SQUARE_BRACKET_CLOSE
		{
			$$ = new Array();						//creating a new Array object
			
			$$->type = $1->type->arrtype;			//type(postfix expr) : type(primary expr)	
						
			$$->Array = $1->Array;				    //array of postfix expr. pointing to array of primary expr.
			
			$$->location = gentemp(new symboltype("int"));		//generating a temporary variable and storing its location
			
			$$->atype = "arr";						//typeOf(Array value) : array
			
			if($1->atype == "arr")                  //checking the case of multidimensional array
			{
				sym* temp_var = gentemp(new symboltype("int"));   //generated a new entry in the symbol table of type(int)
				
				int sz = computeSize($$->type);       			 // sz : sizeOf(postfix expression)
				
				string str = convertInt2String(sz);  			 // str : string(sz)
				
				//computing base address of variable for multidimensional array
				emit("*",temp_var->name,$3->location->name,str);
					
				emit("+",$$->location->name,$1->location->name,temp_var->name);  
				
			}
			else                     //one-dimensional array case
			{                         
				int sz = computeSize($$->type);					// sz : sizeOf(postfix expression)
				
				string str = convertInt2String(sz);				// str : string(sz)
				
				//computing base address of variable for single dimensional array
				emit("*",$$->location->name,$3->location->name,str);
				
			}
		}
		| postfix_expression ROUND_BRACKET_OPEN argument_expression_list_opt ROUND_BRACKET_CLOSE	          //function defination with 0 or more parameters
		{     
			$$=new Array();							//creating a Array object
			
			$$->Array=gentemp($1->type);			//specifying return value of the function
			
			string str=convertInt2String($3);		//str : string(count # of arguments)
			
			emit("call",$$->Array->name,$1->Array->name,str);   //call func_name,str where str is # of arguments in func_name defination
			
		}
		| postfix_expression DOT IDENTIFIER      {     }		
		| postfix_expression IMPLIES IDENTIFIER  {     }
		| postfix_expression UNARY_INCREMENT                 //unary increment operator after a expression
		{
			$$=new Array();									 //creating an Array object
			
			$$->Array=gentemp($1->Array->type);              //generating temporary variable of type(postfix expression)
				
			emit("=",$$->Array->name,$1->Array->name);       //first copy instruction 
			
			emit("+",$1->Array->name,$1->Array->name,"1");   //then increment and store the new values
			    
		}
		| postfix_expression UNARY_DECREMENT				//unary increment operator after a expression
		{
			$$=new Array();									//creating an Array object
			
			$$->Array=gentemp($1->Array->type);				//generating temporary variable of type(postfix expression)
				
			emit("=",$$->Array->name,$1->Array->name);		//first copy instruction 
			
			emit("-",$1->Array->name,$1->Array->name,"1");  //then decrement and store the new values
			    
		}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE CURLY_BRACKET_OPEN initializer_list CURLY_BRACKET_CLOSE       {	    }
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE CURLY_BRACKET_OPEN initializer_list COMMA CURLY_BRACKET_CLOSE {		}
		;


argument_expression_list_opt 
	  	: argument_expression_list
	  	{
	  		$$ = $1;						//equating the expression structure
	  	}
	  	| %empty
	  	{
	  		$$ = 0;                         //initilising # of parameters = 0 in case function argument list is empty
	  	}
	  	;


argument_expression_list 
		: assignment_expression
		{    
			$$=1;                              //only fucntion argument
			
			emit("param",$1->location->name);  //emit parameter instruction
			
		}
	  	| argument_expression_list COMMA assignment_expression
	    {
			$$=$1+1;                           //increment # of function arguments
			
			emit("param",$3->location->name);  //emit parameter instruction
			
	    }
	  	;


unary_expression 
		: postfix_expression						
		{
			$$ = $1;    						//equality of unary and postfix expression
		}
		| UNARY_INCREMENT unary_expression      //unary increment operator before an expression
		{
			emit("+",$2->Array->name,$2->Array->name,"1");  //incrementing value of expression value by 1
			
			$$=$2;										    //assigning the new value to the LHS expression
			   
		}
		| UNARY_DECREMENT unary_expression		//unary decrement operator before an expression
		{
			emit("-",$2->Array->name,$2->Array->name,"1");  //decrementing value of expression value by 1
			
			$$=$2;											//assigning the new value to the LHS expression
			   
		}
		| unary_operator cast_expression                    //unary operator before an expression
		{      	
			$$=new Array();									//creating an Array object
			
			switch($1)				//checking the type of unary operator
			{	  
				case '&':           //generating a temporary variable of pointer data type
					$$->Array=gentemp((new symboltype("ptr")));
					
					$$->Array->type->arrtype=$2->Array->type;   //assigning the data type of the value to be pointed to as the data type of cast expression 
					
					emit("=&",$$->Array->name,$2->Array->name);  //pointer reference instruction
					
					break;

				case '*':            //unary expression stores the value of a pointer
					$$->atype="ptr";
					
					$$->location=gentemp($2->Array->type->arrtype);   //assigning value pointed to, by the cast expression pointer
					
					$$->Array=$2->Array;							 
					
					emit("=*",$$->location->name,$2->Array->name);    //pointer value assigned instruction
					
					break;

				case '+':  
					$$=$2;				//unary plus sign does not matter
					break;
					                    
				case '-':				//unary minus
					$$->Array=gentemp(new symboltype($2->Array->type->type));  //generating temporary varible for storing negative value of expression value
					
					emit("MINUS",$$->Array->name,$2->Array->name);
					
					break;

				case '~':                   //bitwise not
					$$->Array=gentemp(new symboltype($2->Array->type->type));   //generating temporary variable of the same base type to store the negation of expression value
					
					emit("~",$$->Array->name,$2->Array->name);
					
					break;

				case '!':				//logical not
					$$->Array=gentemp(new symboltype($2->Array->type->type));
					//generate temporary variable of the same base type and storing the negation of boolean value of the expression
					
					emit("!",$$->Array->name,$2->Array->name);
					
					break;
			}
		}
		| SIZEOF unary_expression 									{	}
		| SIZEOF ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE	{	}
		;


unary_operator
		: BITWISE_AND
		{
			$$ = '&';					//assigning operator
			
		}
		| MUL
		{
			$$ = '*';					//assigning operator
			
		}
		| PLUS
		{
			$$ = '+';					//assigning operator
			
		}
		| MINUS
		{
			$$ = '-';					//assigning operator
			
		}
		| COMPLEMENT
		{
			$$ = '~';					//assigning operator
			
		}
		| NOT
		{
			$$ = '!';					//assigning operator
			
		}
		;


cast_expression 
		: unary_expression
		{
			$$ = $1;     				//equating the value of expressions
		}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE cast_expression
		{ 								//explicit type conversion of data
			$$=new Array();				//creating an Array object
				
			$$->Array=convertType($4->Array,var_type);    //storing the new value of the cast expression obtained after performing the required conversion 
			
		}
		;


multiplicative_expression 
		: cast_expression 					   //assigning value of expr
		{
			$$ = new Expression();             //creating an Expression object	
									    
			if($1->atype=="arr") 			   //cast expr is of type 'array'
			{
				$$->location = gentemp($1->location->type);	  //generating a temporary and storing its Symbol table location
				
				emit("=[]",  $$->location->name,$1->Array->name, $1->location->name);       
				
			}
			else if($1->atype=="ptr")         //cast expr is of type 'pointer'
			{ 
				$$->location = $1->location;       //assinging the location value of cast expr
				
			}
			else 							//assigning Array value for none of array and pointer case
			{
				$$->location = $1->Array;		
				
			}
		}
		| multiplicative_expression MUL cast_expression       //for multiplication
		{ 
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->Array))  
			{    
				cout << " Mismatch of Data Type " << endl;	      //print error for mismatch of data types
			}
			else 
			{
				$$ = new Expression();	
				
				//generate a temporary to store the value after multiplication
				$$->location = gentemp(new symboltype($1->location->type->type));
				
				emit("*",$$->location->name,$1->location->name, $3->Array->name);
				
			}
		}
		| multiplicative_expression DIV cast_expression         //for division
		{ 
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->Array)) 
			{        
				cout<<"	Mismatch of Data Type "<< endl;	       //print error for mismatch of data types
			}
			else 
			{
				$$ = new Expression();	
				
				//generate a temporary to store the value after division
				$$->location = gentemp(new symboltype($1->location->type->type));
				
				emit("/",$$->location->name,$1->location->name, $3->Array->name);
				
			}
		}
		| multiplicative_expression MOD cast_expression            //for modulus 
		{ 
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->Array))  
			{       
				cout<<"	Mismatch of Data Type "<< endl;         	//print error for mismatch of data types
			}
			else
			{
				$$ = new Expression();	
				
				//generate a temporary to store the value after doing modulus
				$$->location = gentemp(new symboltype($1->location->type->type));
				
				emit("%",$$->location->name,$1->location->name, $3->Array->name);
				
			}
		}
		;


additive_expression 
		: multiplicative_expression
		{ 
			$$ = $1;   					//equating the two expressions
		}
		| additive_expression PLUS multiplicative_expression    //for addition
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location))
			{
				cout <<" Mismatch of Data Type "<< endl;       //print error for mismatch of data types
			}
			else    
			{
				$$ = new Expression();	
				
				//generate a temporary to store the value after performing addition
				$$->location = gentemp(new symboltype($1->location->type->type));
				
				emit("+",$$->location->name, $1->location->name, $3->location->name);
				
			}
		}
		| additive_expression MINUS multiplicative_expression      //for subtraction
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location))
			{
				cout << " Mismatch of Data Type "<< endl;          //print error for mismatch of data types
			}
			else 
			{
				$$ = new Expression();	
				
				//generate a temporary to store the value after performing subtraction
				$$->location = gentemp(new symboltype($1->location->type->type));
				
				emit("-",$$->location->name, $1->location->name, $3->location->name);
				
			}
		}
		;


shift_expression 
		: additive_expression
		{
			$$ = $1;  					//equating the value of 2 expressions
		}
		| shift_expression BITWISE_LEFT additive_expression     //for bitwise left
		{ 
			
			//Ensure shifting left is to be done by a constant
			if(!($3->location->type->type == "int"))
			{
				cout << " Shifting cannot be done : Not an integer value "<< endl; 						//print error 
			}
			else           
			{		
				$$ = new Expression();	
				
				//generate a temporary to store the value after performing left shift
				$$->location = gentemp(new symboltype("int"));
				
				emit("<<",$$->location->name, $1->location->name, $3->location->name);
				
			}
		}
		| shift_expression BITWISE_RIGHT additive_expression      //for bitwise right 
		{ 
			
			//Ensure shifting right is to be done by a constant
			if(!($3->location->type->type == "int"))
			{
				cout << " Shifting cannot be done : Not an integer value "<< endl; 						//print error 
			}
			else            
			{		
				$$ = new Expression();	
				
				//generate a temporary to store the value after performing right shift
				$$->location = gentemp(new symboltype("int"));
				
				emit(">>", $$->location->name, $1->location->name, $3->location->name);
				
			}
		}
		;


relational_expression 
		: shift_expression
		{ 
			$$ = $1;				//equating the value of 2 expressions
		}
		| relational_expression LESS_THAN shift_expression       //for less than
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl;       //print error for mismatch of data types
			}
			else 
			{     								
				$$ = new Expression();
				
				$$->type = "bool";                   //resultant value is boolean
						
				$$->trueList = makelist(nextinstr()); //creating truelist for bool expression
				
				$$->falseList = makelist(nextinstr()+1); //creating falselist for bool expression
				
				emit("<","",$1->location->name, $3->location->name);
				//emit statement if a<b goto .. 
				
				emit("goto", "");	//emit statement goto ..
				
			}
		} 
		| relational_expression GREATER_THAN shift_expression        //for greater than
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl;			//print error for mismatch of data types
			}
			else 
			{							
				$$ = new Expression();
				
				$$->type = "bool";                   //resultant value is boolean
						
				$$->trueList = makelist(nextinstr());     //creating truelist for bool expression
				
				$$->falseList = makelist(nextinstr()+1);  //creating falselist for bool expression
				
				emit(">","",$1->location->name, $3->location->name);
				//emit statement if a>b goto .. 
				
				emit("goto", "");	//emit statement goto ..
				
			}
		}
		| relational_expression LESS_EQUAL shift_expression         //for less than and equal to
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl;          //print error for mismatch of data types
			}
			else 
			{    							
				$$ = new Expression();
				
				$$->type = "bool";                  //resultant value is boolean
						
				$$->trueList = makelist(nextinstr());     //creating truelist for bool expression
				
				$$->falseList = makelist(nextinstr()+1);  //creating falselist for bool expression
				
				emit("<=","",$1->location->name, $3->location->name);
				//emit statement if a<=b goto .. 
				
				emit("goto", "");	//emit statement goto ..
				
			}
		}
		| relational_expression GREATER_EQUAL shift_expression        //for greater than and equal to
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl;			//print error for mismatch of data types
			}
			else 
			{    							
				$$ = new Expression();
				
				$$->type = "bool";                  //resultant value is boolean
						
				$$->trueList = makelist(nextinstr());     //creating truelist for bool expression
				
				$$->falseList = makelist(nextinstr()+1);  //creating falselist for bool expression
				
				emit(">=","",$1->location->name, $3->location->name);
				//emit statement if a>=b goto .. 
				
				emit("goto", "");	//emit statement goto ..
				
			}
		}
		;


equality_expression 
		: relational_expression
		{
			$$ = $1;   					//equating the value of 2 expressions
		}
		| equality_expression EQUAL relational_expression       //for equality of 2 expressions
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl;       //print error for mismatch of data types
			}
			else 
			{
				convertBool2Int($1);                  //convert bool to int value
					
				convertBool2Int($3);				   //convert bool to int value
				
				$$ = new Expression();				   //creating an Expression object
				
				$$->type = "bool";					   //data type of new expr is boolean
				
				$$->trueList = makelist(nextinstr());      //creating truelist for bool expression
				$$->falseList = makelist(nextinstr()+1);   //creating falselist for bool expression
				
				emit("==", "", $1->location->name, $3->location->name);      
				//emit if a==b goto ..
				
				emit("goto", "");				//emit goto ..
				
			}
			
		}
		| equality_expression NOT_EQUAL relational_expression
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location))  
			{
				cout <<" Mismatch of Data Type "<< endl;        //print error for mismatch of data types
			}
			else 
			{
				convertBool2Int($1);                 //convert bool to int value
					
				convertBool2Int($3);                 //convert bool to int value
				
				$$ = new Expression();				  //creating an Expression object
				
				$$->type = "bool";                    //data type of new expr is boolean
				
				$$->trueList = makelist(nextinstr());    //creating truelist for bool expression
				$$->falseList = makelist(nextinstr()+1); //creating falselist for bool expression
				
				emit("!=", "", $1->location->name, $3->location->name);      
				//emit if a!=b goto ..
				
				emit("goto", "");				//emit goto ..
				
			}
			
		}
		;


AND_expression 
		: equality_expression
		{
			$$ = $1; 				//equating the value of 2 expressions
		}
		| AND_expression BITWISE_AND equality_expression
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location))
			{	
				cout << " Mismatch of Data Type "<< endl;        //print error for mismatch of data types
			}
			else 
			{            
				convertBool2Int($1);                 //convert bool to int value
				
				convertBool2Int($3);                 //convert bool to int value
				
				$$ = new Expression(); 				  //creating an Expression object
				
				$$->type = "not-boolean";             //result is not boolean
				
				$$->location = gentemp(new symboltype("int"));
				
				emit("&", $$->location->name, $1->location->name,$3->location->name);
				//emit the quad
				
			}
		}
		;


exclusive_OR_expression 
		: AND_expression
		{
			$$ = $1;    			//equating the value of 2 expressions
		}
		| exclusive_OR_expression XOR AND_expression
		{
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location))    
			{
				cout << " Mismatch of Data Type "<< endl;       //print error for mismatch of data types
			}
			else 
			{
				convertBool2Int($1);                //convert bool to int value
				
				convertBool2Int($3);                //convert bool to int value
				
				$$ = new Expression(); 				  //creating an Expression object
				
				$$->type = "not-boolean";            //result is not boolean
				
				$$->location = gentemp(new symboltype("int"));
				
				emit("^", $$->location->name, $1->location->name, $3->location->name); 
				//emit the quad
				
			}
		}
		;


inclusive_OR_expression 
		: exclusive_OR_expression
		{
			$$ = $1;    			//equating the value of 2 expressions
		}
		| inclusive_OR_expression BITWISE_OR exclusive_OR_expression
		{ 
			
			//check compatibility of data types of both RHS expressions
			if(!TypeCheck($1->location, $3->location))
			{
				cout << "Mismatch of Data Type "<< endl;       //print error for mismatch of data types
			}
			else 
			{
				convertBool2Int($1);	            //convert bool to int value	
				
				convertBool2Int($3);               //convert bool to int value
				
				$$ = new Expression(); 				//creating an Expression object
				
				$$->type = "not-boolean";           //result is not boolean
				
				$$->location = gentemp(new symboltype("int"));
				
				emit("|", $$->location->name, $1->location->name, $3->location->name);
				//emit quad
				
			} 
		}
 		;


logical_AND_expression 
		: inclusive_OR_expression
		{
			$$ = $1;        			//equating the value of 2 expressions
		}
		| logical_AND_expression N LOGICAL_AND M inclusive_OR_expression
		{ 
			
			convertInt2Bool($5);    //convert inclusive_OR_expression int to bool
			
			backpatch($2->nextList, nextinstr()); //$2->nextList goes to next instr
			
			convertInt2Bool($1);   //convert logical_AND_expression to bool
			
			$$ = new Expression();  //Create new boolean expression 
			
			$$->type = "bool";
			
			backpatch($1->trueList, $4);        //if $1 is true, we move to $5
			
			$$->trueList = $5->trueList;        //if $5 is also true, we get trueList for $$
			
			$$->falseList = merge($1->falseList, $5->falseList);   
			 //merge their falseLists
			
		}
		;


logical_OR_expression 
		: logical_AND_expression
		{
			$$ = $1;         			//equating the value of 2 expressions
		}
		| logical_OR_expression N LOGICAL_OR M logical_AND_expression
		{ 
			
			convertInt2Bool($5);    //convert inclusive_OR_expression int to bool
			
			backpatch($2->nextList, nextinstr()); //$2->nextList goes to next instr
			
			convertInt2Bool($1); //convert logical_AND_expression to bool
			
			$$ = new Expression();     //create new boolean expression 
			
			$$->type = "bool";
			
			backpatch($1->falseList, $4);        //if $1 is true, we move to $5
			
			$$->trueList = merge($1->trueList, $5->trueList);
			//if $5 is also true, we get trueList for $$
			
			$$->falseList = $5->falseList;
			 //merge their falseLists
			
		}
		;


conditional_expression 
		: logical_OR_expression
		{
			$$ = $1;           			//equating the value of 2 expressions
		}
		| logical_OR_expression N QUES_MARK M expression N COLON M  conditional_expression
		{
			
			$$->location = gentemp($5->location->type);       //generate temporary for storing the value of expression
			
			$$->location->update($5->location->type);
			
			emit("=", $$->location->name, $9->location->name);  //copy value instruction
			
			
			list<int> l = makelist(nextinstr());     //makelist next instruction
			emit("goto", "");                        //prevent fallthrough
			
			
			backpatch($6->nextList, nextinstr());    //after N, go to next instruction
			
			emit("=", $$->location->name, $5->location->name);
			
			
			list<int> m = makelist(nextinstr());    //makelist next instruction
			
			l = merge(l, m);						//merge the two lists
			
			emit("goto", "");						//prevent fallthrough
			
			
			backpatch($2->nextList, nextinstr());   //backpatching
			
			convertInt2Bool($1);                   //convert expression to boolean
			
			backpatch($1->trueList, $4);           //$1 true goes to expression
			
			backpatch($1->falseList, $8);          //$1 false goes to conditional_expression
			
			backpatch(l, nextinstr());
			
		}
		;


assignment_expression 
		: conditional_expression
		{
			$$ = $1;            	//equating the value of 2 expressions    
		}
		| unary_expression assignment_operator assignment_expression
		{
			
			if($1->atype=="arr")       //if type is arr, simply check if we need to convert and emit
			{
				$3->location = convertType($3->location, $1->type->type);
				
				emit("[]=", $1->Array->name, $1->location->name, $3->location->name);		
				
			}
			else if($1->atype=="ptr")     //if type is ptr, simply emit
			{
				emit("*=", $1->Array->name, $3->location->name);		
				
			}
			else                          //otherwise copy the value
			{
				$3->location = convertType($3->location, $1->Array->type->type);
				emit("=", $1->Array->name, $3->location->name);
				
			}
			
			$$ = $3;
		}
		;


assignment_operator
		: ASSIGN     			{	}
		| MUL_ASSIGN			{	}
		| DIV_ASSIGN			{	}
		| MOD_ASSIGN			{	}
		| PLUS_ASSIGN			{	}
		| MINUS_ASSIGN			{	}
		| BITWISE_LEFT_ASSIGN	{	}
		| BITWISE_RIGHT_ASSIGN	{	}
		| BITWISE_AND_ASSIGN	{	}
		| XOR_ASSIGN			{	}
		| BITWISE_OR_ASSIGN		{	}
		;


expression 
		: assignment_expression
		{
			$$ = $1;            	//equating the value of 2 expressions
		}
		| expression COMMA assignment_expression 	{	}
		;


constant_expression 
		: conditional_expression   {	}
		;


// -------------------------------- 2. DECLARATIONS ------------------------------


declaration 
		: declaration_specifiers init_declarator_list_opt SEMICOLON	{	}
		;


init_declarator_list_opt 
		: init_declarator_list 	{	}
		| %empty 				{	}
		;


declaration_specifiers 
		: storage_class_specifier declaration_specifiers_opt	{	}
		| type_specifier declaration_specifiers_opt				{	}
		| type_qualifier declaration_specifiers_opt				{	}
		| function_specifier declaration_specifiers_opt			{	}
		;


declaration_specifiers_opt 
		: declaration_specifiers {	}
		| %empty				 {	}	
		;


init_declarator_list 
		: init_declarator 								{	}
		| init_declarator_list COMMA init_declarator 	{	}
		;


init_declarator 
		: declarator  
		{
			$$=$1;	             	//equating the value of 2 expressions  
		}
		| declarator ASSIGN initializer
		{
			if($3->val!="") 
				$1->val=$3->val;    //initialising declarator with value of initializer
			emit("=", $1->name, $3->name);     //copy value instruction
			
		}
		;

storage_class_specifier 
		: EXTERN 	{	}
		| STATIC	{	}
		;

type_specifier       
		: VOID   {  var_type = "void";  }
		| CHAR   {  var_type = "char";  }
		| SHORT  {   					}
		| INT 	 {  var_type = "int";   }
		| LONG   {   					}
		| FLOAT  {  var_type = "float"; }
		| DOUBLE {   					}
		;

specifier_qualifier_list 
		: type_specifier specifier_qualifier_list_opt	{	}
		| type_qualifier specifier_qualifier_list_opt	{	}
		;

specifier_qualifier_list_opt 
		: specifier_qualifier_list  {	}
		| %empty					{	}
		;

type_qualifier 
		: CONST 	{	}
		| RESTRICT	{	}
		| VOLATILE	{	}
		;

function_specifier 
		: INLINE 	{	}
		;

declarator 
		: pointer direct_declarator
		{
			symboltype *t = $1;
			
			//for multidimensional arrays, move in depth until base type is obtained
			while(t->arrtype!=NULL) 
				t = t->arrtype;          
			
			t->arrtype = $2->type;                //add the base type 
			
			$$ = $2->update($1);                  //update
			
		}
		| direct_declarator		{	}
		;


direct_declarator 
		: IDENTIFIER         
		{
			$$ = $1->update(new symboltype(var_type));   //add a new variable of var_type
			
			currSymbolPtr = $$;
			
		}
		| ROUND_BRACKET_OPEN declarator ROUND_BRACKET_CLOSE  
		{ 
			$$ = $2; 						//equating the value of declarators
		}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list assignment_expression SQUARE_BRACKET_CLOSE		{	}
		| direct_declarator SQUARE_BRACKET_OPEN assignment_expression SQUARE_BRACKET_CLOSE		
		{
			symboltype *t = $1->type;   //creating symbol of type(declarator)
			
			symboltype *prev = NULL;
			
			while(t->type == "arr") 
			{
				prev = t;	
				t = t->arrtype;      //keep moving recursively to get basetype
				
			}
			if(prev==NULL) 
			{
				int temp = atoi($3->location->val.c_str());      //get initial value
				
				symboltype* s = new symboltype("arr", $1->type, temp);        //create new symbol with that initial value
				
				$$ = $1->update(s);   //update the symbol table
				
			}
			else 
			{
				prev->arrtype =  new symboltype("arr", t, atoi($3->location->val.c_str()));
				
				$$ = $1->update($1->type);
				
			}
		}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list    SQUARE_BRACKET_CLOSE		{	}
		| direct_declarator SQUARE_BRACKET_OPEN SQUARE_BRACKET_CLOSE		
		{
			symboltype *t = $1->type;  //creating symbol of type(declarator)
			
			symboltype *prev = NULL;
			
			while(t->type == "arr") 
			{
				prev = t;	
				t = t->arrtype;         //keep moving recursively to base type
				
			}
			if(prev==NULL) 
			{
				symboltype* s = new symboltype("arr", $1->type, 0);    //no initial values, simply keep 0
				
				$$ = $1->update(s);
					
			}
			else 
			{
				prev->arrtype =  new symboltype("arr", t, 0);
				
				$$ = $1->update($1->type);
				
			}
		}
		| direct_declarator SQUARE_BRACKET_OPEN STATIC type_qualifier_list assignment_expression SQUARE_BRACKET_CLOSE		   {   }
		| direct_declarator SQUARE_BRACKET_OPEN STATIC assignment_expression SQUARE_BRACKET_CLOSE		                         {   }
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list STATIC assignment_expression SQUARE_BRACKET_CLOSE          {   }
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list MUL SQUARE_BRACKET_CLOSE                                {   }
		| direct_declarator SQUARE_BRACKET_OPEN MUL SQUARE_BRACKET_CLOSE  {   }
		| direct_declarator ROUND_BRACKET_OPEN changetable parameter_type_list ROUND_BRACKET_CLOSE
		{
			ST->name = $1->name;		//stating the name of the symbol table
			
			if($1->type->type !="void") 		//if function has a return type
			{
				sym *s = ST->lookup("return");   //lookup for return value	
				s->update($1->type);
				
			}
			$1->nested=ST;       
				
			ST->parent = globalST;			    //directing the parent pointer
			
			ST = globalST;				// Come back to globalsymbol table
			
			currSymbolPtr = $$;
			
		}
		| direct_declarator ROUND_BRACKET_OPEN changetable ROUND_BRACKET_CLOSE
		{    
			ST->name = $1->name;		//stating the name of the symbol table
			
			if($1->type->type !="void")  	     //if function has a return type
			{
				sym *s = ST->lookup("return");   //lookup for return value	
				s->update($1->type);
				
							
			}
			$1->nested=ST;
			
			ST->parent = globalST;		        //directing the parent pointer
			
			ST = globalST;				// Come back to globalsymbol table
			
			currSymbolPtr = $$;
			
		}
		| direct_declarator ROUND_BRACKET_OPEN identifier_list ROUND_BRACKET_CLOSE
		{   }
		;

changetable
		: %empty 
		{ 	// Used for changing to symbol table for a function
			if(currSymbolPtr->nested==NULL) 
			{
				ST = new symtable("");  	//Function symbol table doesn't already exist
				
			}
			else 
			{
				ST = currSymbolPtr ->nested;//Function symbol table already exists
				
				emit("label", ST->name);
				
			}
		}
		;
pointer 
		: MUL type_qualifier_list_opt
		{ 
			$$ = new symboltype("ptr");				//creating a symbol of type 'pointer'
			 
		}        
		| MUL type_qualifier_list_opt pointer
		{ 
			$$ = new symboltype("ptr",$3);         //creating a symbol of type 'pointer'
			
		}
		;

type_qualifier_list 
		: type_qualifier  						{   }
		| type_qualifier_list type_qualifier 	{	}
		;


type_qualifier_list_opt 
		: type_qualifier_list  {	}
		| %empty			   {	}
		;


parameter_type_list 
		: parameter_list 			 {	 }
		| parameter_list COMMA DOTS  {	 }
		;


parameter_list 
		: parameter_declaration							{	}
		| parameter_list COMMA parameter_declaration	{	}
		;


parameter_declaration 
		: declaration_specifiers declarator  	{	}
		| declaration_specifiers 				{	}
		;


identifier_list 
		: IDENTIFIER 						 {    }
		| identifier_list COMMA IDENTIFIER   {	  }
		;


type_name 
		: specifier_qualifier_list {   }
		;


initializer 
		: assignment_expression
		{
			$$ = $1->location;  //equating the value of expression to initialiser
		}
		| CURLY_BRACKET_OPEN initializer_list CURLY_BRACKET_CLOSE        {  }
		| CURLY_BRACKET_OPEN initializer_list COMMA CURLY_BRACKET_CLOSE  {  }
		;


initializer_list 
		: designation_opt initializer 						  {  }
		| initializer_list COMMA designation_opt initializer  {  }
		;


designation 
		: designator_list ASSIGN  {   }
		;


designation_opt 
		: designation 	{	}
		| %empty		{	}
		;


designator_list 
		: designator                 {   }
		| designator_list designator {   }
		;


designator 
		: SQUARE_BRACKET_OPEN constant_expression SQUARE_BRACKET_CLOSE  {   }
		| DOT IDENTIFIER                                                {   }
		;


// -------------------------------- 3. STATEMENTS ------------------------------


statement 
		: labeled_statement  {    }
		| compound_statement
		{	
			$$ = $1;  					//equating the value of the statements
		}
		| expression_statement
		{ 
			$$=new Statement();         //create new statement with same nextList
			$$->nextList=$1->nextList; 
		}
		| selection_statement
		{
			$$ = $1;  					//equating the value of the statements
		}
		| iteration_statement
		{
			$$ = $1;  					//equating the value of the statements 
		}
		| jump_statement
		{
			$$ = $1;  					//equating the value of the statements   
		}
		;


labeled_statement 
		: IDENTIFIER COLON statement 				{	}
		| CASE constant_expression COLON statement  {	}
		| DEFAULT COLON statement 					{	}
		;


compound_statement 
		: CURLY_BRACKET_OPEN block_item_list_opt CURLY_BRACKET_CLOSE  
		{
			$$=$2;  					//equating the value of the statements	  
		}
		;


block_item_list 
		: block_item
		{
			$$ = $1;  					//equating the value of the statements
		}
		| block_item_list M block_item
		{
			$$ = $3;  					//equating the value of the statements
			backpatch($1->nextList,$2);		//after $1, move to block_item via $2
		}
		;


block_item 
		: declaration
		{
			$$ = new Statement();    	//create a new Statement object  
		}
		| statement
		{
			$$ = $1;  					//equating the value of the statements
		}
		;


block_item_list_opt 
		: block_item_list  
		{ 
			$$ = $1;  					//equating the value of the statements 
		}
		| %empty           
		{  
			$$ = new Statement();        //create a new Statement object
		}
		;


expression_statement 
		: expression_opt SEMICOLON    {   }
		;


expression_opt 
		: expression
		{
			$$ = $1;   					//equating the value of the statements
		}
		| %empty
		{
			$$ = new Expression();		//creating a new Expression object
 		}
		;


selection_statement 
		: IF ROUND_BRACKET_OPEN expression N ROUND_BRACKET_CLOSE M statement N %prec "LOWER_THAN_ELSE"
		{
			backpatch($4->nextList, nextinstr());//nextList of N goes to nextinstr
			
			convertInt2Bool($3);        		 //convert expression to bool
			
			$$ = new Statement();        		 //Create a new Statement object
			
			backpatch($3->trueList, $6);         //if expression is true, go to M i.e just before statement body
			
			list<int> temp = merge($3->falseList, $7->nextList);   
			//merge falseList of expression, nextList of statement and second N
			
			$$->nextList = merge($8->nextList, temp);
			
		}
		| IF ROUND_BRACKET_OPEN expression N ROUND_BRACKET_CLOSE M statement N ELSE M statement
		{
			backpatch($4->nextList, nextinstr()); //nextList of N goes to nextinstr
			
			convertInt2Bool($3);        		 //convert expression to bool
			
			$$ = new Statement();       		 //create a new Statement object
			
			backpatch($3->trueList, $6);         //when expression is true, go to M1 else go to M2
			
			backpatch($3->falseList, $10);
			
			list<int> temp = merge($7->nextList, $8->nextList);       
			//merge the nextLists of the statements and second N
			
			$$->nextList = merge($11->nextList,temp);	
				
		}
		| SWITCH ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement {   }
		;


iteration_statement 
		: WHILE M ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE M statement  
		{
			$$ = new Statement();    		//create a new Statement object
			
			convertInt2Bool($4);    	    //convert int value to bool
			
			backpatch($7->nextList, $2);	// M1 to go back to expression again
			
			backpatch($4->trueList, $6);	// M2 to go to statement if the expression is true
			
			$$->nextList = $4->falseList;   //when expression is false, move out of loop
			
			// Emit to prevent fallthrough
			string str=convertInt2String($2);			
			
			emit("goto", str);
				
		}
		| DO M statement M WHILE ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE SEMICOLON
		{
			$$ = new Statement();     		//create a new Statement object
			
			convertInt2Bool($7);      		//convert int value to bool
			
			backpatch($7->trueList, $2);	// M1 to go back to statement if expression is true
			
			backpatch($3->nextList, $4);	// M2 to go to check expression if statement is complete
			
			$$->nextList = $7->falseList;  //move out if statement is false
				
		}
		| FOR ROUND_BRACKET_OPEN expression_statement M expression_statement ROUND_BRACKET_CLOSE M statement
		{
			$$ = new Statement();     		//create a new Statement object
			
			convertInt2Bool($5);      		//convert int value to bool
			
			backpatch($5->trueList,$7);     //if expression is true, go to M2
			
			backpatch($8->nextList,$4);     //after statement, go back to M1
			
			string str=convertInt2String($4);
			
			emit("goto", str);              //prevent fallthrough
			
			$$->nextList = $5->falseList;   //move out if statement is false
			
		}
		| FOR ROUND_BRACKET_OPEN expression_statement M expression_statement M expression N ROUND_BRACKET_CLOSE M statement
		{
			$$ = new Statement();     		//create a new Statement object
			
			convertInt2Bool($5);           //convert int value to boolean
			
			backpatch($5->trueList, $10);	//if expression is true, go to M2
			
			backpatch($8->nextList, $4);	//after N, go back to M1
			
			backpatch($11->nextList, $6);	//statement go back to expression
			
			string str=convertInt2String($6);
			
			emit("goto", str);				//prevent fallthrough
			
			$$->nextList = $5->falseList;	//move out if statement is false	
				
		}
		;


jump_statement 
		: GOTO IDENTIFIER SEMICOLON
		{
			$$ = new Statement();      		//create a new Statement object 
		}
		| CONTINUE SEMICOLON
		{
			$$ = new Statement();           //create a new Statement object   
		}
		| BREAK SEMICOLON
		{
			$$ = new Statement();      		//create a new Statement object    
		}
		| RETURN expression SEMICOLON
		{
			$$ = new Statement();     		//create a new Statement object
			
			//emit return with the name of the return value
			emit("return",$2->location->name);
			
		}
		| RETURN SEMICOLON
		{
			$$ = new Statement();     		//create a new Statement object
			
			emit("return","");              //emit return
			
		}
		;


// -------------------------------- 4. EXTERNAL DEFINITIONS  --------------------


translation_unit 
		: external_declaration                   {   }
		| translation_unit external_declaration  {   }
		;


external_declaration
		: function_definition  {	}
		| declaration          {    }
		;


function_definition
		: declaration_specifiers declarator declaration_list_opt changetable compound_statement
		{
			
			ST->parent=globalST;	      //directing parent pointer to global ST
			
			ST = globalST;        //once we come back to this at the end, change the table to global Symbol table
			
		}
		;


declaration_list
		: declaration                   {   }
        | declaration_list declaration  {   }
		;


declaration_list_opt
		: declaration_list  {   }
		| %empty            {   }
		;

M 		: %empty 
		{
			// backpatching,stores the index of the next quad to be generated
			// Used in various control statements
			$$=nextinstr();
		}   
		;

N 		: %empty
		{
			// backpatching,inserts a goto and stores the index of the next goto statement to guard against fallthrough
			$$ =new Statement();        //we have defined nextList for Statements
			$$->nextList=makelist(nextinstr());
			emit("goto","");
		}
		;


%%

// Called on error in case invalid input is obtained that cannot
// parsed by the parser generated by Bison
void yyerror(string str) {  
	cout << str << endl;
}

